<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Planarity Nexus ‚Äî Crossing Minimization Solver</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: Segoe UI, Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        background: #fff;
        border-radius: 18px;
        padding: 22px;
        max-width: 1200px;
        width: 100%;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.25);
      }
      h1 {
        text-align: center;
        color: #667eea;
        margin-bottom: 10px;
      }
      .top-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }
      .stats {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .stat {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        padding: 10px 14px;
        border-radius: 10px;
        min-width: 120px;
        text-align: center;
      }
      canvas {
        display: block;
        margin: 14px auto;
        border-radius: 10px;
        background: #f8f9fa;
        border: 3px solid #667eea;
        cursor: grab;
      }
      canvas:active {
        cursor: grabbing;
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 10px;
      }
      button,
      select,
      input[type="range"] {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 700;
        transition: opacity 0.2s;
      }
      button:hover,
      select:hover {
        opacity: 0.9;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .rules {
        margin-top: 10px;
        color: #333;
        font-size: 0.95em;
      }
      .rules ol {
        margin-left: 20px;
        margin-top: 5px;
      }
      .rules li {
        margin: 3px 0;
      }
      .victory {
        display: none;
        position: fixed;
        right: 30px;
        top: 50%;
        transform: translateY(-50%);
        background: #fff;
        padding: 26px;
        border-radius: 16px;
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
        z-index: 1000;
        text-align: center;
        max-width: 300px;
      }
      .victory.show {
        display: block;
      }
      .victory h2 {
        color: #667eea;
        margin-bottom: 15px;
      }
      .victory button {
        margin-top: 15px;
      }
      #victoryStats div {
        margin: 8px 0;
        color: #333;
      }
      .mode-selector {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-top: 10px;
        justify-content: center;
      }
      .mode-btn {
        padding: 6px 12px;
        border-radius: 6px;
        background: #e0e0e0;
        color: #333;
        border: 2px solid transparent;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
      }
      .mode-btn.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
      }
      .collaborative-info {
        text-align: center;
        margin-top: 10px;
        padding: 8px;
        background: #f0f0f0;
        border-radius: 8px;
        font-weight: bold;
        display: none;
      }
      .collaborative-info.show {
        display: block;
      }
      .player1 {
        color: #667eea;
      }
      .player2 {
        color: #e74c3c;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üéÆ Planarity Nexus ‚Äî Crossing Minimization Solver</h1>
      <div class="top-row">
        <div class="stats">
          <div class="stat">
            <div class="label">Level</div>
            <div id="levelDisplay">1</div>
          </div>
          <div class="stat">
            <div class="label">Crossings</div>
            <div id="crossings">0</div>
          </div>
          <div class="stat">
            <div class="label">Moves</div>
            <div id="moves">0</div>
          </div>
          <div class="stat">
            <div class="label">Time</div>
            <div id="timer">0s</div>
          </div>
          <div class="stat">
            <div class="label">Planarity Score</div>
            <div id="score">0%</div>
          </div>
        </div>
        <div style="display: flex; gap: 8px; align-items: center">
          <label style="color: #333">Difficulty:</label>
          <input id="difficulty" type="range" min="1" max="10" value="1" />
        </div>
      </div>

      <div class="mode-selector">
        <span style="color: #333; font-weight: bold">Mode:</span>
        <button class="mode-btn active" onclick="game.setMode('2d')">2D</button>
        <button class="mode-btn" onclick="game.setMode('3d')">3D</button>
        <button class="mode-btn" onclick="game.setMode('collaborative')">
          Collaborative
        </button>
      </div>

      <div class="collaborative-info" id="collabInfo">
        Current Turn: <span id="currentPlayer" class="player1">Player 1</span>
      </div>

      <canvas id="canvas" width="900" height="600"></canvas>

      <div class="controls">
        <button onclick="game.reset()">üîÑ Reset</button>
        <button onclick="game.getHint()">üí° Hint</button>
        <button onclick="game.autoSolve()" id="solveBtn">
          ü§ñ Auto Solve (AI)
        </button>
        <button onclick="game.generateGraph()">üé≤ New Graph</button>
        <button onclick="game.changeLevel(-1)">‚¨áÔ∏è Easier</button>
        <button onclick="game.changeLevel(1)">‚¨ÜÔ∏è Harder</button>
      </div>

      <div class="rules">
        <strong>Game Rules</strong>
        <ol>
          <li>
            Move nodes freely; edges must not cross except at shared endpoints.
          </li>
          <li>Game ends when no edge crossings remain.</li>
          <li>
            Score depends on moves, time, complexity; bonuses for spacing &
            edge-length.
          </li>
          <li>
            <strong>Level System:</strong> Complete puzzles to advance through
            progressively harder levels!
          </li>
          <li>
            <strong>3D Mode:</strong> Rotate and manipulate graphs in 3D space
            (mouse wheel to zoom, drag to rotate).
          </li>
          <li>
            <strong>Collaborative Mode:</strong> Two players take turns moving
            nodes to solve together.
          </li>
        </ol>
      </div>
    </div>

    <div class="victory" id="victory">
      <h2>üéâ Victory!</h2>
      <div id="victoryStats"></div>
      <button onclick="game.nextLevel()">‚û°Ô∏è Next Level</button>
      <button
        onclick="game.generateGraph(); document.getElementById('victory').classList.remove('show')"
      >
        üîÑ Retry Level
      </button>
    </div>

    <script>
      // Distance helper
      function dist(a, b) {
        if (a.z !== undefined && b.z !== undefined) {
          return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
        }
        return Math.hypot(a.x - b.x, a.y - b.y);
      }

      class Graph {
        constructor(is3D = false) {
          this.nodes = [];
          this.edges = [];
          this.initialState = null;
          this.is3D = is3D;
        }
        addNode(x, y, z = 0) {
          this.nodes.push({ x, y, z, id: this.nodes.length });
        }
        addEdge(a, b) {
          this.edges.push({ from: a, to: b });
        }
        saveInitialState() {
          this.initialState = this.nodes.map((n) => ({ ...n }));
        }
        reset() {
          if (this.initialState)
            this.nodes = this.initialState.map((n) => ({ ...n }));
        }

        countCrossings() {
          let c = 0;
          for (let i = 0; i < this.edges.length; i++)
            for (let j = i + 1; j < this.edges.length; j++)
              if (this.edgesIntersect(this.edges[i], this.edges[j])) c++;
          return c;
        }

        edgesIntersect(e1, e2) {
          const p1 = this.nodes[e1.from],
            p2 = this.nodes[e1.to],
            p3 = this.nodes[e2.from],
            p4 = this.nodes[e2.to];

          if (
            [e1.from, e1.to].includes(e2.from) ||
            [e1.from, e1.to].includes(e2.to)
          )
            return false;

          const det =
            (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);
          if (Math.abs(det) < 1e-10) return false;
          const t =
            ((p3.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p3.y - p1.y)) /
            det;
          const u =
            ((p3.x - p1.x) * (p2.y - p1.y) - (p2.x - p1.x) * (p3.y - p1.y)) /
            det;
          return t > 0 && t < 1 && u > 0 && u < 1;
        }

        getEdgeColor(e) {
          for (const o of this.edges) {
            if (o === e) continue;
            if (this.edgesIntersect(e, o)) return "#ff4444";
          }
          return "#44bb66";
        }

        averageEdgeLength() {
          if (!this.edges.length) return 0;
          let s = 0;
          for (const e of this.edges)
            s += dist(this.nodes[e.from], this.nodes[e.to]);
          return s / this.edges.length;
        }

        spacingUniformityScore() {
          const d = this.nodes.map((n, i) => {
            let nearest = Infinity;
            for (let j = 0; j < this.nodes.length; j++)
              if (i !== j) nearest = Math.min(nearest, dist(n, this.nodes[j]));
            return nearest;
          });
          const mean = d.reduce((a, b) => a + b, 0) / d.length;
          const variance =
            d.reduce((a, b) => a + (b - mean) ** 2, 0) / d.length;
          const std = Math.sqrt(variance);
          return mean ? Math.max(0, 1 - std / mean) : 1;
        }
      }

      class PlanarityGame {
        constructor() {
          this.canvas = document.getElementById("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.graph = new Graph();
          this.selectedNode = null;
          this.moves = 0;
          this.startTime = null;
          this.timerInterval = null;
          this.level = 1;
          this.solving = false;
          this.initialCrossings = 0;
          this.mode = "2d";
          this.rotation = { x: 0, y: 0 };
          this.zoom = 1;
          this.collaborative = false;
          this.currentPlayer = 1;

          this.canvas.addEventListener(
            "mousedown",
            this.onMouseDown.bind(this)
          );
          this.canvas.addEventListener(
            "mousemove",
            this.onMouseMove.bind(this)
          );
          this.canvas.addEventListener("wheel", this.onWheel.bind(this));
          window.addEventListener("mouseup", this.onMouseUp.bind(this));

          document
            .getElementById("difficulty")
            .addEventListener("input", (e) => {
              this.level = Number(e.target.value);
              this.generateGraph();
            });

          this.generateGraph();
        }

        setMode(mode) {
          this.mode = mode;
          document
            .querySelectorAll(".mode-btn")
            .forEach((btn) => btn.classList.remove("active"));
          event.target.classList.add("active");

          if (mode === "collaborative") {
            this.collaborative = true;
            this.currentPlayer = 1;
            document.getElementById("collabInfo").classList.add("show");
          } else {
            this.collaborative = false;
            document.getElementById("collabInfo").classList.remove("show");
          }

          if (mode === "3d") {
            this.graph = new Graph(true);
          } else {
            this.graph = new Graph(false);
          }

          this.generateGraph();
        }

        generateGraph() {
          const nodeCount = Math.min(5 + this.level * 2, 25);
          const edgeProbability = Math.min(0.15 + this.level * 0.03, 0.5);

          this._generateRandom(nodeCount, edgeProbability);
        }

        _generateRandom(n, p) {
          this.graph = new Graph(this.mode === "3d");
          const w = this.canvas.width;
          const h = this.canvas.height;

          for (let i = 0; i < n; i++) {
            const angle = (Math.PI * 2 * i) / n + (Math.random() - 0.5) * 0.6;
            const radius = 120 + Math.random() * 150;
            const x = w / 2 + Math.cos(angle) * radius;
            const y = h / 2 + Math.sin(angle) * radius;
            const z = this.mode === "3d" ? (Math.random() - 0.5) * 200 : 0;
            this.graph.addNode(
              x + (Math.random() - 0.5) * 30,
              y + (Math.random() - 0.5) * 30,
              z
            );
          }

          // Generate edges ensuring graph has crossings
          let attempts = 0;
          do {
            this.graph.edges = [];

            for (let i = 0; i < n; i++)
              for (let j = i + 1; j < n; j++)
                if (Math.random() < p) this.graph.addEdge(i, j);

            for (let i = 0; i < n - 1; i++)
              if (Math.random() < 0.6) this.graph.addEdge(i, (i + 1) % n);

            // Ensure no isolated nodes
            const nodeDegrees = Array(n).fill(0);
            for (const e of this.graph.edges) {
              nodeDegrees[e.from]++;
              nodeDegrees[e.to]++;
            }
            for (let i = 0; i < n; i++) {
              if (nodeDegrees[i] === 0) {
                let nearest = (i + 1) % n;
                let minDist = dist(
                  this.graph.nodes[i],
                  this.graph.nodes[nearest]
                );
                for (let j = 0; j < n; j++) {
                  if (i !== j) {
                    const d = dist(this.graph.nodes[i], this.graph.nodes[j]);
                    if (d < minDist) {
                      minDist = d;
                      nearest = j;
                    }
                  }
                }
                this.graph.addEdge(i, nearest);
              }
            }

            attempts++;
          } while (this.graph.countCrossings() === 0 && attempts < 20);

          // If still no crossings, add some crossing edges
          if (this.graph.countCrossings() === 0 && n >= 4) {
            this.graph.addEdge(0, Math.floor(n / 2));
            this.graph.addEdge(1, Math.floor(n / 2) + 1);
          }

          this._finalize();
        }

        _finalize() {
          this.moves = 0;
          this.solving = false;
          this.currentPlayer = 1;
          document.getElementById("solveBtn").disabled = false;
          document.getElementById("victory").classList.remove("show");
          this.graph.saveInitialState();
          this.initialCrossings = this.graph.countCrossings();
          document.getElementById("levelDisplay").textContent = this.level;
          this.startTimer();
          this.draw();
        }

        changeLevel(d) {
          this.level = Math.max(1, Math.min(this.level + d, 10));
          document.getElementById("difficulty").value = this.level;
          this.generateGraph();
        }

        nextLevel() {
          this.level = Math.min(this.level + 1, 10);
          document.getElementById("difficulty").value = this.level;
          document.getElementById("victory").classList.remove("show");
          this.generateGraph();
        }

        reset() {
          this.graph.reset();
          this.moves = 0;
          this.currentPlayer = 1;
          this.solving = false;
          document.getElementById("solveBtn").disabled = false;
          this.startTimer();
          this.draw();
        }

        startTimer() {
          if (this.timerInterval) clearInterval(this.timerInterval);
          this.startTime = Date.now();
          this.timerInterval = setInterval(() => {
            const e = Math.floor((Date.now() - this.startTime) / 1000);
            document.getElementById("timer").textContent = e + "s";
          }, 200);
        }

        getHint() {
          const crossings = this.graph.countCrossings();
          if (crossings === 0) {
            alert("Graph is already planar! üéâ");
            return;
          }
          const nodeCrossCounts = Array(this.graph.nodes.length).fill(0);
          for (let i = 0; i < this.graph.edges.length; i++)
            for (let j = i + 1; j < this.graph.edges.length; j++)
              if (
                this.graph.edgesIntersect(
                  this.graph.edges[i],
                  this.graph.edges[j]
                )
              ) {
                nodeCrossCounts[this.graph.edges[i].from]++;
                nodeCrossCounts[this.graph.edges[i].to]++;
                nodeCrossCounts[this.graph.edges[j].from]++;
                nodeCrossCounts[this.graph.edges[j].to]++;
              }
          let worst = 0,
            maxC = -1;
          nodeCrossCounts.forEach((c, i) => {
            if (c > maxC) {
              maxC = c;
              worst = i;
            }
          });
          this.selectedNode = worst;
          this.draw();
          setTimeout(() => {
            this.selectedNode = null;
            this.draw();
          }, 2000);
          alert(
            "üí° Hint: Try moving node #" +
              (worst + 1) +
              " ‚Äî it participates in many crossings."
          );
        }

        autoSolve() {
          if (this.solving) return;
          this.solving = true;
          document.getElementById("solveBtn").disabled = true;
          const maxIterations = 2000;
          let iteration = 0;
          let stuckCount = 0;
          let lastCrossings = this.graph.countCrossings();

          const applyForceDirected = (iterations = 50) => {
            const k = Math.sqrt(
              (this.canvas.width * this.canvas.height) / this.graph.nodes.length
            );
            const temp = 100;
            const cooling = 0.95;

            for (let iter = 0; iter < iterations; iter++) {
              const forces = this.graph.nodes.map(() => ({ x: 0, y: 0, z: 0 }));
              const t = temp * Math.pow(cooling, iter);

              for (let i = 0; i < this.graph.nodes.length; i++) {
                for (let j = i + 1; j < this.graph.nodes.length; j++) {
                  const dx =
                    this.graph.nodes[j].x - this.graph.nodes[i].x || 0.01;
                  const dy =
                    this.graph.nodes[j].y - this.graph.nodes[i].y || 0.01;
                  const dz =
                    this.mode === "3d"
                      ? this.graph.nodes[j].z - this.graph.nodes[i].z || 0.01
                      : 0;
                  const d = Math.hypot(dx, dy, dz);
                  const repulsion = (k * k) / (d * d);
                  const fx = (dx / d) * repulsion;
                  const fy = (dy / d) * repulsion;
                  const fz = this.mode === "3d" ? (dz / d) * repulsion : 0;
                  forces[i].x -= fx;
                  forces[i].y -= fy;
                  forces[i].z -= fz;
                  forces[j].x += fx;
                  forces[j].y += fy;
                  forces[j].z += fz;
                }
              }

              for (const e of this.graph.edges) {
                const dx =
                  this.graph.nodes[e.to].x - this.graph.nodes[e.from].x;
                const dy =
                  this.graph.nodes[e.to].y - this.graph.nodes[e.from].y;
                const dz =
                  this.mode === "3d"
                    ? this.graph.nodes[e.to].z - this.graph.nodes[e.from].z
                    : 0;
                const d = Math.hypot(dx, dy, dz) || 0.01;
                const attraction = (d * d) / k;
                const fx = (dx / d) * attraction;
                const fy = (dy / d) * attraction;
                const fz = this.mode === "3d" ? (dz / d) * attraction : 0;
                forces[e.from].x += fx;
                forces[e.from].y += fy;
                forces[e.from].z += fz;
                forces[e.to].x -= fx;
                forces[e.to].y -= fy;
                forces[e.to].z -= fz;
              }

              for (let i = 0; i < this.graph.nodes.length; i++) {
                const mag =
                  Math.hypot(forces[i].x, forces[i].y, forces[i].z) || 0.01;
                const scale = Math.min(mag, t) / mag;
                this.graph.nodes[i].x += forces[i].x * scale * 0.3;
                this.graph.nodes[i].y += forces[i].y * scale * 0.3;
                if (this.mode === "3d")
                  this.graph.nodes[i].z += forces[i].z * scale * 0.3;

                this.graph.nodes[i].x = Math.max(
                  30,
                  Math.min(this.canvas.width - 30, this.graph.nodes[i].x)
                );
                this.graph.nodes[i].y = Math.max(
                  30,
                  Math.min(this.canvas.height - 30, this.graph.nodes[i].y)
                );
                if (this.mode === "3d")
                  this.graph.nodes[i].z = Math.max(
                    -200,
                    Math.min(200, this.graph.nodes[i].z)
                  );
              }
            }
          };

          const tryImproveNode = (i) => {
            const node = this.graph.nodes[i];
            const orig = { x: node.x, y: node.y, z: node.z };
            let bestPos = { ...orig };
            let bestCross = this.graph.countCrossings();

            const candidates = [];

            for (let a = 0; a < 16; a++) {
              const ang = (a * Math.PI * 2) / 16;
              for (const r of [40, 80, 120, 160]) {
                candidates.push({
                  x: orig.x + Math.cos(ang) * r,
                  y: orig.y + Math.sin(ang) * r,
                  z:
                    this.mode === "3d"
                      ? orig.z + (Math.random() - 0.5) * 100
                      : 0,
                });
              }
            }

            const nc = this._neighborCentroid(i);
            if (nc) {
              for (const mult of [-2, -1.5, -1, 1.5, 2, 2.5]) {
                const dx = orig.x - nc.x;
                const dy = orig.y - nc.y;
                candidates.push({
                  x: orig.x + dx * mult,
                  y: orig.y + dy * mult,
                  z: this.mode === "3d" ? orig.z : 0,
                });
              }
            }

            const gridSize = 60;
            for (let gx = 1; gx < this.canvas.width / gridSize; gx++) {
              for (let gy = 1; gy < this.canvas.height / gridSize; gy++) {
                candidates.push({
                  x: gx * gridSize,
                  y: gy * gridSize,
                  z: this.mode === "3d" ? (Math.random() - 0.5) * 200 : 0,
                });
              }
            }

            for (const c of candidates) {
              c.x = Math.max(30, Math.min(this.canvas.width - 30, c.x));
              c.y = Math.max(30, Math.min(this.canvas.height - 30, c.y));
              if (this.mode === "3d") c.z = Math.max(-200, Math.min(200, c.z));

              this.graph.nodes[i].x = c.x;
              this.graph.nodes[i].y = c.y;
              this.graph.nodes[i].z = c.z;
              const cr = this.graph.countCrossings();
              if (cr < bestCross) {
                bestCross = cr;
                bestPos = { x: c.x, y: c.y, z: c.z };
              }
            }

            this.graph.nodes[i].x = bestPos.x;
            this.graph.nodes[i].y = bestPos.y;
            this.graph.nodes[i].z = bestPos.z;
            return bestCross < this.graph.countCrossings();
          };

          const iterationStep = () => {
            if (!this.solving) return;
            iteration++;

            if (iteration % 100 === 0) {
              applyForceDirected(30);
            }

            const nodeScores = Array(this.graph.nodes.length).fill(0);
            for (let a = 0; a < this.graph.edges.length; a++) {
              for (let b = a + 1; b < this.graph.edges.length; b++) {
                if (
                  this.graph.edgesIntersect(
                    this.graph.edges[a],
                    this.graph.edges[b]
                  )
                ) {
                  nodeScores[this.graph.edges[a].from]++;
                  nodeScores[this.graph.edges[a].to]++;
                  nodeScores[this.graph.edges[b].from]++;
                  nodeScores[this.graph.edges[b].to]++;
                }
              }
            }

            const nodesOrder = nodeScores
              .map((s, i) => ({ s, i }))
              .sort((p, q) => q.s - p.s)
              .map((o) => o.i);

            for (let idx = 0; idx < Math.min(nodesOrder.length, 5); idx++) {
              tryImproveNode(nodesOrder[idx]);
            }

            this.draw();

            const c = this.graph.countCrossings();

            if (c === lastCrossings) {
              stuckCount++;
            } else {
              stuckCount = 0;
              lastCrossings = c;
            }

            if (c === 0) {
              this.solving = false;
              document.getElementById("solveBtn").disabled = false;
              this.draw();
              this.victory();
              return;
            }

            if (stuckCount > 20) {
              applyForceDirected(100);
              stuckCount = 0;
            }

            if (iteration >= maxIterations) {
              this.solving = false;
              document.getElementById("solveBtn").disabled = false;
              this.draw();
              alert(
                `Auto-solver finished after ${maxIterations} iterations.\nCrossings remaining: ${c}\n\nTry manual moves or hints!`
              );
              return;
            }

            setTimeout(iterationStep, 10);
          };

          applyForceDirected(100);
          this.draw();
          setTimeout(iterationStep, 50);
        }

        _neighborCentroid(i) {
          const neighbors = this.graph.edges
            .filter((e) => e.from === i || e.to === i)
            .map((e) =>
              e.from === i ? this.graph.nodes[e.to] : this.graph.nodes[e.from]
            );
          if (!neighbors.length) return null;
          const c = neighbors.reduce(
            (acc, n) => {
              acc.x += n.x;
              acc.y += n.y;
              acc.z += n.z || 0;
              return acc;
            },
            { x: 0, y: 0, z: 0 }
          );
          c.x /= neighbors.length;
          c.y /= neighbors.length;
          c.z /= neighbors.length;
          return c;
        }

        onWheel(e) {
          if (this.mode === "3d") {
            e.preventDefault();
            this.zoom += e.deltaY * -0.001;
            this.zoom = Math.max(0.5, Math.min(3, this.zoom));
            this.draw();
          }
        }

        onMouseDown(e) {
          if (this.solving) return;
          const r = this.canvas.getBoundingClientRect();
          const x = e.clientX - r.left;
          const y = e.clientY - r.top;

          if (this.mode === "3d" && e.shiftKey) {
            this.rotating = true;
            this.lastMouse = { x, y };
            return;
          }

          for (let i = 0; i < this.graph.nodes.length; i++) {
            const projected =
              this.mode === "3d"
                ? this.project3D(this.graph.nodes[i])
                : this.graph.nodes[i];
            if (Math.hypot(x - projected.x, y - projected.y) < 14) {
              this.selectedNode = i;
              break;
            }
          }
        }

        onMouseMove(e) {
          const r = this.canvas.getBoundingClientRect();
          const x = Math.max(
            20,
            Math.min(this.canvas.width - 20, e.clientX - r.left)
          );
          const y = Math.max(
            20,
            Math.min(this.canvas.height - 20, e.clientY - r.top)
          );

          if (this.mode === "3d" && this.rotating) {
            const dx = x - this.lastMouse.x;
            const dy = y - this.lastMouse.y;
            this.rotation.y += dx * 0.01;
            this.rotation.x += dy * 0.01;
            this.lastMouse = { x, y };
            this.draw();
            return;
          }

          if (this.selectedNode === null || this.solving) return;

          this.graph.nodes[this.selectedNode].x = x;
          this.graph.nodes[this.selectedNode].y = y;
          this.draw();
        }

        onMouseUp() {
          this.rotating = false;
          if (this.selectedNode !== null && !this.solving) {
            this.moves++;

            if (this.collaborative) {
              this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
              const playerSpan = document.getElementById("currentPlayer");
              playerSpan.textContent = `Player ${this.currentPlayer}`;
              playerSpan.className =
                this.currentPlayer === 1 ? "player1" : "player2";
            }

            this.selectedNode = null;
            this.draw();
            if (this.graph.countCrossings() === 0) this.victory();
          }
        }

        project3D(node) {
          const cx = this.canvas.width / 2;
          const cy = this.canvas.height / 2;

          let x = node.x - cx;
          let y = node.y - cy;
          let z = node.z || 0;

          const cosX = Math.cos(this.rotation.x);
          const sinX = Math.sin(this.rotation.x);
          const cosY = Math.cos(this.rotation.y);
          const sinY = Math.sin(this.rotation.y);

          let y1 = y * cosX - z * sinX;
          let z1 = y * sinX + z * cosX;

          let x2 = x * cosY + z1 * sinY;
          let z2 = -x * sinY + z1 * cosY;

          const scale = 200 / (200 + z2);

          return {
            x: cx + x2 * scale * this.zoom,
            y: cy + y1 * scale * this.zoom,
            scale: scale,
          };
        }

        victory() {
          if (this.timerInterval) clearInterval(this.timerInterval);
          const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
          const complexity =
            this.graph.edges.length + this.graph.nodes.length * 2;
          const base = Math.max(
            0,
            Math.round(1000 - this.moves * 10 - elapsed * 2 + complexity * 5)
          );
          const spacingBonus = Math.round(
            100 * this.graph.spacingUniformityScore()
          );
          const lengthBonus = Math.round(
            Math.max(0, 100 - Math.abs(this.graph.averageEdgeLength() - 140)) /
              10
          );
          const finalScore = Math.max(0, base + spacingBonus + lengthBonus);

          document.getElementById("victoryStats").innerHTML = `
            <div>Level: ${this.level}</div>
            <div>Moves: ${this.moves}</div>
            <div>Time: ${elapsed}s</div>
            <div>Nodes: ${this.graph.nodes.length} ‚Ä¢ Edges: ${this.graph.edges.length}</div>
            <div>Complexity bonus: ${complexity}</div>
            <div>Spacing bonus: ${spacingBonus}</div>
            <div>Final Score: ${finalScore}</div>
          `;
          document.getElementById("victory").classList.add("show");
        }

        draw() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          if (this.mode === "3d") {
            this.draw3D();
          } else {
            this.draw2D();
          }

          const crossings = this.graph.countCrossings();
          document.getElementById("crossings").textContent = crossings;
          document.getElementById("moves").textContent = this.moves;
          const planarityScore =
            this.initialCrossings > 0
              ? Math.max(
                  0,
                  Math.round(100 * (1 - crossings / this.initialCrossings))
                )
              : 100;
          document.getElementById("score").textContent = planarityScore + "%";
        }

        draw2D() {
          for (const e of this.graph.edges) {
            const a = this.graph.nodes[e.from];
            const b = this.graph.nodes[e.to];
            this.ctx.strokeStyle = this.graph.getEdgeColor(e);
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.moveTo(a.x, a.y);
            this.ctx.lineTo(b.x, b.y);
            this.ctx.stroke();
          }

          for (let i = 0; i < this.graph.nodes.length; i++) {
            const n = this.graph.nodes[i];
            this.ctx.fillStyle =
              i === this.selectedNode ? "#ff6b6b" : "#667eea";
            this.ctx.beginPath();
            this.ctx.arc(n.x, n.y, 12, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 3;
            this.ctx.stroke();
            this.ctx.fillStyle = "white";
            this.ctx.font = "bold 10px Arial";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(i + 1, n.x, n.y);
          }
        }

        draw3D() {
          const projected = this.graph.nodes.map((n) => this.project3D(n));
          const edgeData = this.graph.edges
            .map((e) => ({
              from: projected[e.from],
              to: projected[e.to],
              color: this.graph.getEdgeColor(e),
              depth: (projected[e.from].scale + projected[e.to].scale) / 2,
            }))
            .sort((a, b) => a.depth - b.depth);

          for (const e of edgeData) {
            this.ctx.strokeStyle = e.color;
            this.ctx.lineWidth = 3 * e.depth;
            this.ctx.beginPath();
            this.ctx.moveTo(e.from.x, e.from.y);
            this.ctx.lineTo(e.to.x, e.to.y);
            this.ctx.stroke();
          }

          const nodeData = projected
            .map((p, i) => ({ p, i }))
            .sort((a, b) => a.p.scale - b.p.scale);

          for (const { p, i } of nodeData) {
            const size = 12 * p.scale;
            this.ctx.fillStyle =
              i === this.selectedNode ? "#ff6b6b" : "#667eea";
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 3 * p.scale;
            this.ctx.stroke();
            this.ctx.fillStyle = "white";
            this.ctx.font = `bold ${Math.floor(10 * p.scale)}px Arial`;
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(i + 1, p.x, p.y);
          }
        }
      }

      const game = new PlanarityGame();
    </script>
  </body>
</html>
